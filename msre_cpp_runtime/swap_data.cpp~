#ifdef MSRE_CONFIG_FILE
#include "msre_config.h"
#endif

#ifndef MSRE_NODE_INSTANCE
#define MSRE_NODE_INSTANCE AdminExpoBackoffMSRENode
#endif

#ifndef MSRE_MPICOMM_INSTANCE
#define MSRE_MPICOMM_INSTANCE MPICommBasic
#endif

#ifndef MSRE_GOAL_INSTANCE
#define MSRE_GOAL_INSTANCE ListGoals
#endif

#ifndef MSRE_DIRECTORY_INSTANCE
#define MSRE_DIRECTORY_INSTANCE UniDirectory
#endif

#include <iostream>
#include <sstream>
#include <string>
#include <list>

#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/unordered_map.hpp>
#include <boost/functional/hash/hash.hpp>
#include <boost/serialization/string.hpp>
#include <boost/serialization/list.hpp>
#include <boost/mpi.hpp>
#include <boost/mpi/status.hpp>
#include <boost/format.hpp>
#include <boost/tuple/tuple.hpp>

#include "msre/fact.h"
#include "msre/comm.h"
#include "msre/store.h"
#include "msre/goals.h"
#include "msre/rewrite.h"
#include "msre/directory.h"
#include "msre/logger.h"			
#include "msre/hash.h"

using namespace std;
using namespace boost;
using namespace boost::tuples;





class Swapper : public MSRE_NODE_INSTANCE {

	struct Fact : public Pretty {
		virtual void execute(Swapper* node) = 0;
		virtual int priority() = 0;
	};

	struct Swap : Fact {
		int loc;
		int arg1;
		int arg2;
		bool alive;
	
		Swap() {}
		Swap(int l, int a1, int a2) : loc(l), arg1(a1), arg2(a2), alive(true) {}
	
		tuple<int,int,int> args() { return make_tuple(loc,arg1,arg2); }
	
		int node_id() { return loc; }
	
		string pretty() {
			return (format("[%s]Swap(%s,%s)") % loc % arg1 % arg2 ).str();
		}
	
		void set_dead() { alive = false; }
	
		void execute(Swapper* ensem) { ensem->execute( this ); }
	
		Swap* identity() { return this; }
	
		Swap* clone() { return new Swap(dcopy(loc),dcopy(arg1),dcopy(arg2)); }
	
		int priority() { return 1; }
	
		friend class boost::serialization::access;
	
		template<class Archive>
		void serialize(Archive & ar, const unsigned int version) {
			ar & loc;
			ar & arg1;
			ar & arg2;
			ar & alive;
		}
	};
	
	struct Data : Fact {
		int loc;
		int arg1;
		bool alive;
	
		Data() {}
		Data(int l, int a1) : loc(l), arg1(a1), alive(true) {}
	
		tuple<int,int> args() { return make_tuple(loc,arg1); }
	
		int node_id() { return loc; }
	
		string pretty() {
			return (format("[%s]Data(%s)") % loc % arg1 ).str();
		}
	
		void set_dead() { alive = false; }
	
		void execute(Swapper* ensem) { ensem->execute( this ); }
	
		Data* identity() { return this; }
	
		Data* clone() { return new Data(dcopy(loc),dcopy(arg1)); }
	
		int priority() { return 1; }
	
		friend class boost::serialization::access;
	
		template<class Archive>
		void serialize(Archive & ar, const unsigned int version) {
			ar & loc;
			ar & arg1;
			ar & alive;
		}
	};
	

	size_t index0Swap(int loc) {
		return loc;
	}
	size_t index1Swap(int arg1) {
		return arg1;
	}
	size_t index0Data(int loc) {
		return loc;
	}

	const static int swap_pred_id = 0;
	const static int data_pred_id = 1;
	
	const mpi::communicator world;
	const int rank;

	MSRE_MPICOMM_INSTANCE<Data> data_comm;

	Goals<Fact>* goals;

	MultimapStore<Swap> swap_store_0;
	MultimapStore<Swap> swap_store_1;
	MultimapStore<Data> data_store_0;

	COUNTER(
	int pivotSwap_rule_count;
	int rule_app_misses;
	)

	public: Swapper() : rank(world.rank()) {
	
		exist_counter = 0;
	
		COUNTER(
		pivotSwap_rule_count = 0;
		rule_app_misses = 0;
		);
	
		dir   = new MSRE_DIRECTORY_INSTANCE(world.size());
		goals = new MSRE_GOAL_INSTANCE<Fact>();
	
		set_pretty_component( goals );
	
		swap_store_0.set_name("Swap Store");
		set_store_component( &swap_store_0 );
		
		swap_store_1.set_name("Swap Store");
		set_store_component( &swap_store_1 );
		
		data_store_0.set_name("Data Store");
		set_store_component( &data_store_0 );
		
	
		data_comm = MSRE_MPICOMM_INSTANCE<Data>(data_pred_id);
	
		LOG(
		string logger_name = (format("node%s") % rank).str();
		init_logger(logger_name, logger_name, "Main");
		set_logger_child( goals, "Goals" );
		set_logger_child( &swap_store_0,"Swap Store" );
		set_logger_child( &swap_store_1,"Swap Store" );
		set_logger_child( &data_store_0,"Data Store" );
		set_logger_child( &data_comm,"Data Comm");
		);
	
		data_comm.init_send();
		data_comm.init_receive();
		
	
		COUNTER(
		set_pretty_counter("pivotSwap rule applications", &pivotSwap_rule_count);
		set_pretty_counter("Store iteration misses", &rule_app_misses);
		set_pretty_counter("Data MPI messages sent", data_comm.get_send_counter());
		set_pretty_counter("Data MPI messages received", data_comm.get_recv_counter());
		
		);
	
	}
	

	private: bool rewrite() {
		bool done_something = false;
		while(goals->has_goals()) {
			Fact* fact = goals->next();
			fact->execute( this );
			done_something = true;
		}
		return done_something;
	}
	
	private: bool rewrite(int max_steps) {
		int count = 0;
		while(goals->has_goals() and count < max_steps) {
			Fact* fact = goals->next();
			fact->execute( this );
			count++;
		}
		return count > 0;
	}

	private: bool receive() {
		bool received = false;
		optional<list<Data*> > opt_1 = data_comm.receive();
		if (opt_1) {
			for (list<Data*>::iterator st = opt_1->begin(); st != opt_1->end(); st++) {
				goals->add( *st );
				received = true;
			}
		}				
		
		return received;
	}
	
	protected: bool globally_quiescence() {
		int ns1 [1] = { *(data_comm.get_send_counter()) };
		int ns2 [1] = { *(data_comm.get_recv_counter()) };
		return all_eq_sum<1>(ns1, ns2);
	}
	

	private: void store(Swap* swap) {
		swap_store_0.add( swap, index0Swap((*swap).loc) );
		swap_store_1.add( swap, index1Swap((*swap).arg1) );
	} 				
	
	private: void store(Data* data) {
		data_store_0.add( data, index0Data((*data).loc) );
	} 				
	
	public: void add_swap(int loc,int arg1,int arg2) {
		int dest = lookup_dir( loc );
		if (dest == rank) {
			goals->add( new Swap(loc,arg1,arg2) );
			
		}
	}
	
	public: void add_data(int loc,int arg1) {
		int dest = lookup_dir( loc );
		if (dest == rank) {
			Data* temp = new Data(loc,arg1);
			goals->add( temp );
			store( temp );
		}
	}
	
	private: void send(Data data) {
		int dest = lookup_dir( data.node_id() );
		if (dest != rank) {
			data_comm.send( dest, data); 
		} else {
			goals->add( data.clone() );
		}
	}
	
	

	/*
	**** 0 Join Ordering of Rule pivotSwap ****
	Active #H0 [X]swap(Y,P)
	LookupAll #H1 1:0:hash<[+]data(-)|.> X [X]data(D)
	FilterGuard #H1 D >= P
	CompreDomain #H1 D Xs [X]data(D)
	LookupAll #H2 1:0:hash<[+]data(-)|.> Y [Y]data(D)
	FilterHead #H2 #H1
	FilterGuard #H2 D < P
	CompreDomain #H2 D Ys [Y]data(D)
	DeleteHead #H0
	DeleteHead #H1
	DeleteHead #H2
	IntroCompre Remote NoPrior NonMono D Xs [Y]data(D)
	IntroCompre Remote NoPrior NonMono D Ys [X]data(D)
	*/
	private: bool execute_swap_join_ordering_1(Swap* act) {
		LOG_RULE_APP( record((format("Attempting occurrence execute_swap_join_ordering_1 on %s") % act->pretty()).str(), THIS_SRC) ); 
		// Join Task: Active #H0 [X]swap(Y,P)
		int x; int y; int p;
		tie(x,y,p) = (*act).args();
		// Join Task: LookupAll #H1 1:0:hash<[+]data(-)|.> X [X]data(D)
		MultimapIter<Data> candidates_1 = data_store_0.lookup_candidates(index0Data(x));
		// Join Task: FilterGuard #H1 D >= P
		CompreIter<Data> candidates_1_0;
		optional<Data*> cand_1_0 = candidates_1.get_next_alive();
		while(cand_1_0) {
			int x; int d;
			tie(x,d) = (**cand_1_0).args();
			if (d >= p) {
				candidates_1_0.add( *cand_1_0 );
			}
			cand_1_0 = candidates_1.get_next_alive();
		}
		candidates_1_0.init_iter();
		// Join Task: CompreDomain #H1 D Xs [X]data(D)
		list<int>  xs;
		optional<Data*> cand_1_1 = candidates_1_0.get_next_alive();
		while(cand_1_1) {
			int x; int d;
			tie(x,d) = (**cand_1_1).args();
			xs.push_back( d );
			cand_1_1 = candidates_1_0.get_next_alive();
		}
		candidates_1_0.init_iter();
		// Join Task: LookupAll #H2 1:0:hash<[+]data(-)|.> Y [Y]data(D)
		MultimapIter<Data> candidates_2 = data_store_0.lookup_candidates(index0Data(y));
		// Join Task: FilterHead #H2 #H1
		// Join Task: FilterGuard #H2 D < P
		CompreIter<Data> candidates_2_0;
		optional<Data*> cand_2_0 = candidates_2.get_next_alive();
		while(cand_2_0) {
			int y; int d;
			tie(y,d) = (**cand_2_0).args();
			if (d < p) {
				candidates_2_0.add( *cand_2_0 );
			}
			cand_2_0 = candidates_2.get_next_alive();
		}
		candidates_2_0.init_iter();
		// Join Task: CompreDomain #H2 D Ys [Y]data(D)
		list<int>  ys;
		optional<Data*> cand_2_1 = candidates_2_0.get_next_alive();
		while(cand_2_1) {
			int y; int d;
			tie(y,d) = (**cand_2_1).args();
			ys.push_back( d );
			cand_2_1 = candidates_2_0.get_next_alive();
		}
		candidates_2_0.init_iter();
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: DeleteHead #H1
		optional<Data*> cand_1_2 = candidates_1_0.get_next_alive();
		while(cand_1_2) {
			data_store_0.remove( *cand_1_2 );
			cand_1_2 = candidates_1_0.get_next_alive();
		}
		// Join Task: DeleteHead #H2
		optional<Data*> cand_2_2 = candidates_2_0.get_next_alive();
		while(cand_2_2) {
			data_store_0.remove( *cand_2_2 );
			cand_2_2 = candidates_2_0.get_next_alive();
		}
		// Join Task: IntroCompre Remote NoPrior NonMono D Xs [Y]data(D)
		list<int>  comp_0 = xs;
		for(list<int> ::iterator it=comp_0.begin(); it!=comp_0.end(); it++) {
			int d;
			d = *it;
			send( Data(y,d) );
		}
		// Join Task: IntroCompre Remote NoPrior NonMono D Ys [X]data(D)
		list<int>  comp_1 = ys;
		for(list<int> ::iterator it=comp_1.begin(); it!=comp_1.end(); it++) {
			int d;
			d = *it;
			Data* body_1 = new Data(x,d);
			goals->add( body_1 );
			store( body_1 );
		}
		COUNTER(pivotSwap_rule_count++);
		LOG_RULE_APP( record((format("Applying pivotSwap(%s,%s,%s,%s,%s)") % to_str(p) % to_str(xs) % to_str(y) % to_str(x) % to_str(ys)).str(), THIS_SRC) ); 
		return false;
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule pivotSwap ****
	Active #H0 [X]data(D)
	LookupAtom #H1 0:0:hash<[+]swap(-,-)|.> X [X]swap(Y,P)
	CheckGuard D >= P
	LookupAll #H2 1:0:hash<[+]data(-)|.> X [X]data(D)
	FilterGuard #H2 D >= P
	CompreDomain #H2 D Xs [X]data(D)
	LookupAll #H3 1:0:hash<[+]data(-)|.> Y [Y]data(D)
	FilterHead #H3 #H2
	FilterGuard #H3 D < P
	CompreDomain #H3 D Ys [Y]data(D)
	DeleteHead #H1
	DeleteHead #H2
	DeleteHead #H3
	IntroCompre Remote NoPrior NonMono D Xs [Y]data(D)
	IntroCompre Remote NoPrior NonMono D Ys [X]data(D)
	*/
	private: bool execute_data_join_ordering_1(Data* act) {
		LOG_RULE_APP( record((format("Attempting occurrence execute_data_join_ordering_1 on %s") % act->pretty()).str(), THIS_SRC) ); 
		// Join Task: Active #H0 [X]data(D)
		int x; int d;
		tie(x,d) = (*act).args();
		// Join Task: LookupAtom #H1 0:0:hash<[+]swap(-,-)|.> X [X]swap(Y,P)
		MultimapIter<Swap> candidates_1 = swap_store_0.lookup_candidates(index0Swap(x));
		optional<Swap*> cand_1 = candidates_1.get_next_alive();
		while(cand_1) {
			int x1; int y; int p;
			tie(x1,y,p) = (**cand_1).args();
			LOG_RULE_APP( record((format("Candidate for cand_1 found -> %s") % (**cand_1).pretty()).str(), THIS_SRC) ); 
			// Join Task: CheckGuard D >= P
			if (d >= p) {
				// Join Task: LookupAll #H2 1:0:hash<[+]data(-)|.> X [X]data(D)
				MultimapIter<Data> candidates_2 = data_store_0.lookup_candidates(index0Data(x));
				// Join Task: FilterGuard #H2 D >= P
				CompreIter<Data> candidates_2_0;
				optional<Data*> cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0) {
					int x; int d;
					tie(x,d) = (**cand_2_0).args();
					if (d >= p) {
						candidates_2_0.add( *cand_2_0 );
					}
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2_0.init_iter();
				// Join Task: CompreDomain #H2 D Xs [X]data(D)
				list<int>  xs;
				optional<Data*> cand_2_1 = candidates_2_0.get_next_alive();
				while(cand_2_1) {
					int x; int d;
					tie(x,d) = (**cand_2_1).args();
					xs.push_back( d );
					cand_2_1 = candidates_2_0.get_next_alive();
				}
				candidates_2_0.init_iter();
				// Join Task: LookupAll #H3 1:0:hash<[+]data(-)|.> Y [Y]data(D)
				MultimapIter<Data> candidates_3 = data_store_0.lookup_candidates(index0Data(y));
				// Join Task: FilterHead #H3 #H2
				// Join Task: FilterGuard #H3 D < P
				CompreIter<Data> candidates_3_0;
				optional<Data*> cand_3_0 = candidates_3.get_next_alive();
				while(cand_3_0) {
					int y; int d;
					tie(y,d) = (**cand_3_0).args();
					if (d < p) {
						candidates_3_0.add( *cand_3_0 );
					}
					cand_3_0 = candidates_3.get_next_alive();
				}
				candidates_3_0.init_iter();
				// Join Task: CompreDomain #H3 D Ys [Y]data(D)
				list<int>  ys;
				optional<Data*> cand_3_1 = candidates_3_0.get_next_alive();
				while(cand_3_1) {
					int y; int d;
					tie(y,d) = (**cand_3_1).args();
					ys.push_back( d );
					cand_3_1 = candidates_3_0.get_next_alive();
				}
				candidates_3_0.init_iter();
				// Join Task: DeleteHead #H1
				swap_store_0.remove( *cand_1 );
				// Join Task: DeleteHead #H2
				optional<Data*> cand_2_2 = candidates_2_0.get_next_alive();
				while(cand_2_2) {
					data_store_0.remove( *cand_2_2 );
					cand_2_2 = candidates_2_0.get_next_alive();
				}
				// Join Task: DeleteHead #H3
				optional<Data*> cand_3_2 = candidates_3_0.get_next_alive();
				while(cand_3_2) {
					data_store_0.remove( *cand_3_2 );
					cand_3_2 = candidates_3_0.get_next_alive();
				}
				// Join Task: IntroCompre Remote NoPrior NonMono D Xs [Y]data(D)
				list<int>  comp_0 = xs;
				for(list<int> ::iterator it=comp_0.begin(); it!=comp_0.end(); it++) {
					int d;
					d = *it;
					send( Data(y,d) );
				}
				// Join Task: IntroCompre Remote NoPrior NonMono D Ys [X]data(D)
				list<int>  comp_1 = ys;
				for(list<int> ::iterator it=comp_1.begin(); it!=comp_1.end(); it++) {
					int d;
					d = *it;
					Data* body_1 = new Data(x,d);
					goals->add( body_1 );
					store( body_1 );
				}
				COUNTER(pivotSwap_rule_count++);
				LOG_RULE_APP( record((format("Applying pivotSwap(%s,%s,%s,%s,%s,%s)") % to_str(p) % to_str(d) % to_str(xs) % to_str(y) % to_str(x) % to_str(ys)).str(), THIS_SRC) ); 
				return false;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule pivotSwap ****
	Active #H0 [Y]data(D)
	LookupAtom #H1 0:1:hash<[-]swap(+,-)|.> Y [X]swap(Y,P)
	CheckGuard D < P
	LookupAll #H2 1:0:hash<[+]data(-)|.> Y [Y]data(D)
	FilterGuard #H2 D < P
	CompreDomain #H2 D Ys [Y]data(D)
	LookupAll #H3 1:0:hash<[+]data(-)|.> X [X]data(D)
	FilterHead #H3 #H2
	FilterGuard #H3 D >= P
	CompreDomain #H3 D Xs [X]data(D)
	DeleteHead #H1
	DeleteHead #H2
	DeleteHead #H3
	IntroCompre Remote NoPrior NonMono D Xs [Y]data(D)
	IntroCompre Remote NoPrior NonMono D Ys [X]data(D)
	*/
	private: bool execute_data_join_ordering_2(Data* act) {
		LOG_RULE_APP( record((format("Attempting occurrence execute_data_join_ordering_2 on %s") % act->pretty()).str(), THIS_SRC) ); 
		// Join Task: Active #H0 [Y]data(D)
		int y; int d;
		tie(y,d) = (*act).args();
		// Join Task: LookupAtom #H1 0:1:hash<[-]swap(+,-)|.> Y [X]swap(Y,P)
		MultimapIter<Swap> candidates_1 = swap_store_1.lookup_candidates(index1Swap(y));
		optional<Swap*> cand_1 = candidates_1.get_next_alive();
		while(cand_1) {
			int x; int y1; int p;
			tie(x,y1,p) = (**cand_1).args();
			LOG_RULE_APP( record((format("Candidate for cand_1 found -> %s") % (**cand_1).pretty()).str(), THIS_SRC) ); 
			// Join Task: CheckGuard D < P
			if (d < p) {
				// Join Task: LookupAll #H2 1:0:hash<[+]data(-)|.> Y [Y]data(D)
				MultimapIter<Data> candidates_2 = data_store_0.lookup_candidates(index0Data(y));
				// Join Task: FilterGuard #H2 D < P
				CompreIter<Data> candidates_2_0;
				optional<Data*> cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0) {
					int y; int d;
					tie(y,d) = (**cand_2_0).args();
					if (d < p) {
						candidates_2_0.add( *cand_2_0 );
					}
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2_0.init_iter();
				// Join Task: CompreDomain #H2 D Ys [Y]data(D)
				list<int>  ys;
				optional<Data*> cand_2_1 = candidates_2_0.get_next_alive();
				while(cand_2_1) {
					int y; int d;
					tie(y,d) = (**cand_2_1).args();
					ys.push_back( d );
					cand_2_1 = candidates_2_0.get_next_alive();
				}
				candidates_2_0.init_iter();
				// Join Task: LookupAll #H3 1:0:hash<[+]data(-)|.> X [X]data(D)
				MultimapIter<Data> candidates_3 = data_store_0.lookup_candidates(index0Data(x));
				// Join Task: FilterHead #H3 #H2
				// Join Task: FilterGuard #H3 D >= P
				CompreIter<Data> candidates_3_0;
				optional<Data*> cand_3_0 = candidates_3.get_next_alive();
				while(cand_3_0) {
					int x; int d;
					tie(x,d) = (**cand_3_0).args();
					if (d >= p) {
						candidates_3_0.add( *cand_3_0 );
					}
					cand_3_0 = candidates_3.get_next_alive();
				}
				candidates_3_0.init_iter();
				// Join Task: CompreDomain #H3 D Xs [X]data(D)
				list<int>  xs;
				optional<Data*> cand_3_1 = candidates_3_0.get_next_alive();
				while(cand_3_1) {
					int x; int d;
					tie(x,d) = (**cand_3_1).args();
					xs.push_back( d );
					cand_3_1 = candidates_3_0.get_next_alive();
				}
				candidates_3_0.init_iter();
				// Join Task: DeleteHead #H1
				swap_store_0.remove( *cand_1 );
				// Join Task: DeleteHead #H2
				optional<Data*> cand_2_2 = candidates_2_0.get_next_alive();
				while(cand_2_2) {
					data_store_0.remove( *cand_2_2 );
					cand_2_2 = candidates_2_0.get_next_alive();
				}
				// Join Task: DeleteHead #H3
				optional<Data*> cand_3_2 = candidates_3_0.get_next_alive();
				while(cand_3_2) {
					data_store_0.remove( *cand_3_2 );
					cand_3_2 = candidates_3_0.get_next_alive();
				}
				// Join Task: IntroCompre Remote NoPrior NonMono D Xs [Y]data(D)
				list<int>  comp_0 = xs;
				for(list<int> ::iterator it=comp_0.begin(); it!=comp_0.end(); it++) {
					int d;
					d = *it;
					Data* body_0 = new Data(y,d);
					goals->add( body_0 );
					store( body_0 );
				}
				// Join Task: IntroCompre Remote NoPrior NonMono D Ys [X]data(D)
				list<int>  comp_1 = ys;
				for(list<int> ::iterator it=comp_1.begin(); it!=comp_1.end(); it++) {
					int d;
					d = *it;
					send( Data(x,d) );
				}
				COUNTER(pivotSwap_rule_count++);
				LOG_RULE_APP( record((format("Applying pivotSwap(%s,%s,%s,%s,%s,%s)") % to_str(p) % to_str(d) % to_str(xs) % to_str(y) % to_str(x) % to_str(ys)).str(), THIS_SRC) ); 
				return false;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	

	private: void execute(Swap* swap) {
		if( execute_swap_join_ordering_1(swap) ) {
			store( swap );
		}
	}
	
	private: void execute(Data* data) {
		if( execute_data_join_ordering_1(data) ) {
			if( execute_data_join_ordering_2(data) ) {
			}
		}
	}
	

};


void execute_0() {
	Swapper en = Swapper();
	int l0 = 0;
	int l1 = 1;
	en.add_node(l0);
	en.add_node(l1);
	en.init();
	en.add_swap(l0,l1,4);
	en.add_data(l0,50);
	en.add_data(l0,60);
	en.add_data(l0,1);
	en.add_data(l1,2);
	en.add_data(l1,3);
	en.add_data(l1,5);
	en.run_stat();
	en.close();
}

int main(int argc, char* argv[]) { 

	mpi::environment env(argc, argv);
	mpi::communicator world;

	if (world.rank() == 0) { print_log_pref(); }

	execute_0();
}

