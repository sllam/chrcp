#ifndef MSRE_EXTERN_H
#define MSRE_EXTERN_H

#include <sstream>
#include <list>
#include <algorithm>

#include <boost/mpi.hpp>
#include <boost/tuple/tuple.hpp>

using namespace std;
using namespace boost;
using namespace boost::tuples;

template <typename T>
int len(std::list<T>& ls) {
	return ls.size();
}

template <typename T>
tuple<list<T>,list<T> > split(list<T>& ls) {
	list<T> ls1, ls2;
	int ls1_size = ls.size() / 2;
	int count = 0;
	for(typename list<T>::iterator it=ls.begin(); it != ls.end() ; it++) {
		if (count < ls1_size) {
			ls1.push_back( *it );
		} else {
			ls2.push_back( *it );
		}
		count++;
	}
	return make_tuple(ls1,ls2);
}

template <typename T>
list<T> merge(list<T>& ls1, list<T>& ls2) {
	typename list<T>::iterator it1 = ls1.begin();
	typename list<T>::iterator it2 = ls2.begin();
	list<T> ls3;
	while(it1 != ls1.end() || it2 != ls2.end()) {
		if(it1 != ls1.end() && it2 != ls2.end()) {
			if (*it1 < *it2) {
				ls3.push_back( *it1 );
				it1++;
			} else {
				ls3.push_back( *it2 );
				it2++;
			}
		} else if(it1 != ls1.end()) {
			ls3.push_back( *it1 );
			it1++;
		} else {
			ls3.push_back( *it2 );
			it2++;
		}
	}
	return ls3;
}

template <typename T>
list<T> sort(list<T>& ls) {
	if (ls.size() > 1) {
		list<T> ls1, ls2;
		tie(ls1,ls2) = split(ls);
		list<T> s_ls = merge(sort(ls1), sort(ls2));
		return s_ls;
	} else {
		return ls;
	}
}

template <typename T>
T first(list<T>& ls) {
	return *(ls.begin());
}

template <typename T>
T median(list<T>& ls) {
	int count = ls.size() / 2;
	typename list<T>::iterator it = ls.begin();
	while(count > 0) { it++; count--; }
	return *it;
}

template <typename T>
tuple<list<T>,list<T> > partition(list<T>& ls, T pv) {
	list<T> ls1, ls2;
	for(typename list<T>::iterator it=ls.begin(); it != ls.end(); it++) {
		if (*it <= pv) {
			ls1.push_back( *it );
		} else {
			ls2.push_back( *it );
		}
	}
	return make_tuple(ls1, ls2);
}

template <typename T>
list<tuple<T,T> > zip(list<T>& ls1, list<T>& ls2) {
	typename list<T>::iterator it1 = ls1.begin();
	typename list<T>::iterator it2 = ls2.begin();
	list<tuple<T,T> > ls;
	while(it1 != ls1.end() and it2 != ls2.end()) {
		ls.push_back( make_tuple(*it1,*it2) );
		it1++; it2++;
	}
	return ls;
}

#endif /* MSRE_EXTERN */
