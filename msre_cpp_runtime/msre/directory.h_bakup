#ifndef MSRE_DIRECTORY_H
#define MSRE_DIRECTORY_H

#include <sstream>
#include <queue>

#include <boost/mpi.hpp>
#include <boost/mpi/status.hpp>
#include <boost/container/map.hpp>
#include <boost/container/set.hpp>

#include "misc.h"
#include "node.h"

using namespace std;
using namespace boost;
namespace bcont = boost::container;

class Directory : public Pretty {

	protected: mpi::communicator world;
	protected: int next_node_id;
	protected: bcont::map<int,Node*> node_map;

	protected: int new_node_id() {
		int new_id = next_node_id;
		next_node_id += world.size();
		return new_id;
	}

	public: virtual void add_edge(int src_id, int dest_id) = 0;
	public: virtual void init() = 0;
	public: virtual int compute_rank(int node_id) = 0;

	public: void register_node(int node_id) {
		node_map.insert( make_pair(node_id, new Node(node_id)) );
		while(next_node_id <= node_id) {
			next_node_id += world.size();
		}
	}

	public: Node* get_node(int node_id) {
		bcont::map<int,Node*>::iterator it = node_map.find( node_id );
		return it->second;
	}

	public: Node* new_node() {
		Node* n = new Node(new_node_id());
		n->set_rank( compute_rank(n.get_node()) );
		return n;
	}

	public: string pretty() {
		stringstream ss;
		ss << "----------------- Directory ---------------------" << endl;
		for(bcont::map<int,Node*>::iterator start = node_map.begin(); start != node_map.end(); start++) {
			ss << start->first << " --> " << (start->second)->get_rank() << endl;
		}
		ss << "-------------------------------------------------" << endl;
		return ss.str();
	}

};

// Maps MSRE nodes directly to MPI ranks
class IdentDirectory: public Directory {

	public: IdentDirectory() {
		next_node_id = world.rank();
	}

	public: void add_edge(int src_id, int dest_id) {}
	public: void init() {
		for(bcont::map<int,Node*>::iterator it = node_map.begin(); it != node_map.end(); it++) {
			Node* n = it->second;
			n->set_rank(n->get_node());
		}
	}
	public int compute_rank(int node_id) { return node_id; }

	public: string pretty() {
		stringstream ss;
		ss << "----------------- Directory ---------------------" << endl;
		ss << "x --> x" << endl;
		ss << "-------------------------------------------------" << endl;
		return ss.str();
	}

};

// Maps all MSRE nodes to a single MPI rank, default rank 0
class UniDirectory: public Directory {

	int rank;

	public: UniDirectory(int r=0) : rank(r) { 
		next_node_id = world.rank();
	}

	public: void add_edge(int src_id, int dest_id) {}
	public: void init() {
		for(bcont::map<int,Node*>::iterator it = node_map.begin(); it != node_map.end(); it++) {
			Node* n = it->second;
			n->set_rank( rank );
		}
	}
	public: int compute_rank(int node_id) { return rank; }

	public: string pretty() {
		stringstream ss;
		ss << "----------------- Directory ---------------------" << endl;
		ss << "x --> " << rank << endl;
		ss << "-------------------------------------------------" << endl;
		return ss.str();
	}
};

/*
class RankNodeCount {

	int rank;
	int inv_count;

	public: RankNodeCount(int r) : rank(r), inv_count(0) {}

	public: int get_rank() { return rank; }

	public: int get_count() { return -inv_count; }

	public: void incr_count() { inv_count--; }

};

class CompareCount {

	public: bool operator()(RankNodeCount& c1, RankNodeCount& c2) {
		return c1.get_count() < c2.get_count();
	}

};
*/

// Maps MSRE nodes to ranks by 'modulo rank distribution'. Hence, this
// ignores any static topology infered from the initial program. 
class ModuloDistDirectory: public Directory {

	int rank_size;

	public: ModuloDistDirectory(int s) : rank_size(s) {
		next_node_id = world.rank();
	}

	public: void add_edge(int src_id, int dest_id) {}
	public: void init() {
		for(bcont::map<int,Node*>::iterator it = node_map.begin(); it != node_map.end(); it++) {
			Node* n = it->second;
			n->set_rank( compute_rank( n->get_node() ) );
		}		
	}
	public: int compute_rank(int node_id) { return node_id % rank_size; }	

};

// Maps MSRE nodes to ranks by 'node value proximity', i.e try to keep nodes of the same value
// in the same rank. Like Modulo distribution this ignores any static topology infered from the 
// initial program. 
class NodeProxyDirectory: public Directory {

	int rank_size;

	public: NodeProxyDirectory(int s) : rank_size(s) {
		next_node_id = world.rank();
	}

	public: void add_edge(int src_id, int dest_id) {}
	public: void init() {
		int node_size = node_map.size();
		int group_size = node_size / rank_size;
		int curr_rank = 0;
		int count = 0;
		for(bcont::map<int,Node*>::iterator it = node_map.begin(); it != node_map.end(); it++) {
			Node* n = it->second;
			if(count > group_size && curr_rank < rank_size) {
				curr_rank += 1;
				count = 0;
			}
			n->set_rank( curr_rank );
			count++;
		}
	}
	public: int compute_rank(int node_id) {
		return node_id % rank_size;
	}

};

#endif /* MSRE_DIRECTORY_H */
