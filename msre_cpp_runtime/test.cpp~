#ifdef MSRE_CONFIG_FILE
#include "msre_config.h"
#endif

#ifndef MSRE_NODE_INSTANCE
#define MSRE_NODE_INSTANCE AdminExpoBackoffMSRENode
#endif

#ifndef MSRE_MPICOMM_INSTANCE
#define MSRE_MPICOMM_INSTANCE MPICommBasic
#endif

#ifndef MSRE_GOAL_INSTANCE
#define MSRE_GOAL_INSTANCE ListGoals
#endif

#ifndef MSRE_DIRECTORY_INSTANCE
#define MSRE_DIRECTORY_INSTANCE NodeProxyDirectory
#endif

#include <iostream>
#include <sstream>
#include <string>
#include <list>

#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/unordered_map.hpp>
#include <boost/functional/hash/hash.hpp>
#include <boost/serialization/string.hpp>
#include <boost/serialization/list.hpp>
#include <boost/mpi.hpp>
#include <boost/mpi/status.hpp>
#include <boost/format.hpp>
#include <boost/tuple/tuple.hpp>

#include "msre/fact.h"
#include "msre/comm.h"
#include "msre/store.h"
#include "msre/goals.h"
#include "msre/rewrite.h"
#include "msre/directory.h"
#include "msre/logger.h"			
#include "msre/hash.h"

using namespace std;
using namespace boost;
using namespace boost::tuples;





class Test : public MSRE_NODE_INSTANCE {

	struct Fact : public Pretty {
		virtual void execute(Test* node) = 0;
		virtual int priority() = 0;
	};

	struct A : Fact {
		int loc;
		list<int>  arg1;
		bool alive;
	
		A() {}
		A(int l, list<int>  a1) : loc(l), arg1(a1), alive(true) {}
	
		tuple<int,list<int> > args() { return make_tuple(loc,arg1); }
	
		int node_id() { return loc; }
	
		string pretty() {
			return (format("[%s]A(%s)") % loc % to_str(arg1) ).str();
		}
	
		void set_dead() { alive = false; }
	
		void execute(Test* ensem) { ensem->execute( this ); }
	
		A* identity() { return this; }
	
		A* clone() { return new A(dcopy(loc),dcopy(arg1)); }
	
		int priority() { return 1; }
	
		friend class boost::serialization::access;
	
		template<class Archive>
		void serialize(Archive & ar, const unsigned int version) {
			ar & loc;
			ar & arg1;
			ar & alive;
		}
	};
	
	struct B : Fact {
		int loc;
		int arg1;
		bool alive;
	
		B() {}
		B(int l, int a1) : loc(l), arg1(a1), alive(true) {}
	
		tuple<int,int> args() { return make_tuple(loc,arg1); }
	
		int node_id() { return loc; }
	
		string pretty() {
			return (format("[%s]B(%s)") % loc % arg1 ).str();
		}
	
		void set_dead() { alive = false; }
	
		void execute(Test* ensem) { ensem->execute( this ); }
	
		B* identity() { return this; }
	
		B* clone() { return new B(dcopy(loc),dcopy(arg1)); }
	
		int priority() { return 1; }
	
		friend class boost::serialization::access;
	
		template<class Archive>
		void serialize(Archive & ar, const unsigned int version) {
			ar & loc;
			ar & arg1;
			ar & alive;
		}
	};
	
	struct C : Fact {
		int loc;
		int arg1;
		bool alive;
	
		C() {}
		C(int l, int a1) : loc(l), arg1(a1), alive(true) {}
	
		tuple<int,int> args() { return make_tuple(loc,arg1); }
	
		int node_id() { return loc; }
	
		string pretty() {
			return (format("[%s]C(%s)") % loc % arg1 ).str();
		}
	
		void set_dead() { alive = false; }
	
		void execute(Test* ensem) { ensem->execute( this ); }
	
		C* identity() { return this; }
	
		C* clone() { return new C(dcopy(loc),dcopy(arg1)); }
	
		int priority() { return 1; }
	
		friend class boost::serialization::access;
	
		template<class Archive>
		void serialize(Archive & ar, const unsigned int version) {
			ar & loc;
			ar & arg1;
			ar & alive;
		}
	};
	
	struct D : Fact {
		int loc;
		list<int>  arg1;
		bool alive;
	
		D() {}
		D(int l, list<int>  a1) : loc(l), arg1(a1), alive(true) {}
	
		tuple<int,list<int> > args() { return make_tuple(loc,arg1); }
	
		int node_id() { return loc; }
	
		string pretty() {
			return (format("[%s]D(%s)") % loc % to_str(arg1) ).str();
		}
	
		void set_dead() { alive = false; }
	
		void execute(Test* ensem) { ensem->execute( this ); }
	
		D* identity() { return this; }
	
		D* clone() { return new D(dcopy(loc),dcopy(arg1)); }
	
		int priority() { return 1; }
	
		friend class boost::serialization::access;
	
		template<class Archive>
		void serialize(Archive & ar, const unsigned int version) {
			ar & loc;
			ar & arg1;
			ar & alive;
		}
	};
	

	

	const static int a_pred_id = 0;
	const static int b_pred_id = 1;
	const static int c_pred_id = 2;
	const static int d_pred_id = 3;
	
	const mpi::communicator world;
	const int rank;

	

	Goals<Fact>* goals;

	ListStore<A> a_store_0;
	ListStore<B> b_store_0;
	ListStore<C> c_store_0;
	ListStore<D> d_store_0;

	COUNTER(
	int mergeAs_rule_count;
	int rule_app_misses;
	)

	public: Test() : rank(world.rank()) {
	
		exist_counter = 0;
	
		COUNTER(
		mergeAs_rule_count = 0;
		rule_app_misses = 0;
		);
	
		dir   = new MSRE_DIRECTORY_INSTANCE(world.size());
		goals = new MSRE_GOAL_INSTANCE<Fact>();
	
		set_pretty_component( goals );
	
		a_store_0.set_name("A Store");
		set_store_component( &a_store_0 );
		
		b_store_0.set_name("B Store");
		set_store_component( &b_store_0 );
		
		c_store_0.set_name("C Store");
		set_store_component( &c_store_0 );
		
		d_store_0.set_name("D Store");
		set_store_component( &d_store_0 );
		
	
		
	
		LOG(
		string logger_name = (format("node%s") % rank).str();
		init_logger(logger_name, logger_name, "Main");
		set_logger_child( goals, "Goals" );
		set_logger_child( &a_store_0,"A Store" );
		set_logger_child( &b_store_0,"B Store" );
		set_logger_child( &c_store_0,"C Store" );
		set_logger_child( &d_store_0,"D Store" );
		
		);
	
		
	
		COUNTER(
		set_pretty_counter("mergeAs rule applications", &mergeAs_rule_count);
		set_pretty_counter("Store iteration misses", &rule_app_misses);
		
		);
	
	}
	

	private: bool rewrite() {
		bool done_something = false;
		while(goals->has_goals()) {
			Fact* fact = goals->next();
			fact->execute( this );
			done_something = true;
		}
		return done_something;
	}
	
	private: bool rewrite(int max_steps) {
		int count = 0;
		while(goals->has_goals() and count < max_steps) {
			Fact* fact = goals->next();
			fact->execute( this );
			count++;
		}
		return count > 0;
	}

	private: bool receive() {
		bool received = false;
		
		return received;
	}
	
	protected: bool globally_quiescence() {
		int ns1 [0] = {  };
		int ns2 [0] = {  };
		return all_eq_sum<0>(ns1, ns2);
	}
	

	private: void store(A* a) {
		a_store_0.add( a );
	} 				
	
	private: void store(B* b) {
		b_store_0.add( b );
	} 				
	
	private: void store(C* c) {
		c_store_0.add( c );
	} 				
	
	private: void store(D* d) {
		d_store_0.add( d );
	} 				
	
	public: void add_a(int loc,list<int>  arg1) {
		int dest = lookup_dir( loc );
		if (dest == rank) {
			goals->add( new A(loc,arg1) );
		}
	}
	
	public: void add_b(int loc,int arg1) {
		int dest = lookup_dir( loc );
		if (dest == rank) {
			goals->add( new B(loc,arg1) );
		}
	}
	
	public: void add_c(int loc,int arg1) {
		int dest = lookup_dir( loc );
		if (dest == rank) {
			goals->add( new C(loc,arg1) );
		}
	}
	
	public: void add_d(int loc,list<int>  arg1) {
		int dest = lookup_dir( loc );
		if (dest == rank) {
			goals->add( new D(loc,arg1) );
		}
	}
	
	
	

	/*
	**** 0 Join Ordering of Rule mergeAs ****
	Active #H0 [X]a(Ys)
	DeleteHead #H0
	IntroCompre Local NoPrior Mono Y Ys [X]b(Y)
	*/
	private: bool execute_a_join_ordering_1(A* act) {
		LOG_RULE_APP( record((format("Attempting occurrence execute_a_join_ordering_1 on %s") % act->pretty()).str(), THIS_SRC) ); 
		int x; list<int>  ys;
		tie(x,ys) = (*act).args();
		list<int>  comp_0 = ys;
		for(list<int> ::iterator it=comp_0.begin(); it!=comp_0.end(); it++) {
			int y;
			y = *it;
			goals->add( new B(x,y) );
		}
		COUNTER(mergeAs_rule_count++);
		LOG_RULE_APP( record((format("Applying mergeAs(%s,%s)") % to_str(x) % to_str(ys)).str(), THIS_SRC) ); 
		return false;
		return true;
	}
	

	private: void execute(A* a) {
		if( execute_a_join_ordering_1(a) ) {
			store( a );
		}
	}
	
	private: void execute(B* b) {
		store( b );
	}
	
	private: void execute(C* c) {
		store( c );
	}
	
	private: void execute(D* d) {
		store( d );
	}
	

};


void execute_0() {
	Merger en = Merger();
	int l0 = 0;
	en.add_node(l0);
	en.init();
	int temp0[] = { 1,2,3 };
	en.add_a(l0,tolist(temp0,3));
	en.run_stat();
	en.close();
}

int main(int argc, char* argv[]) { 

	mpi::environment env(argc, argv);
	mpi::communicator world;

	if (world.rank() == 0) { print_log_pref(); }

	execute_0();
}

