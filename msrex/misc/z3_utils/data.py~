

'''
This file is part of MSR Ensemble (MSRE-X).

MSRE-X is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MSRE-X is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MSRE-X. If not, see <http://www.gnu.org/licenses/>.

MSR Ensemble (MSRE-X) Version 0.5, Prototype Alpha

Authors:
Edmund S. L. Lam      sllam@qatar.cmu.edu
Iliano Cervesato      iliano@cmu.edu

* This implementation was made possible by an NPRP grant (NPRP 09-667-1-100, Effective Programming 
for Large Distributed Ensembles) from the Qatar National Research Fund (a member of the Qatar 
Foundation). The statements made herein are solely the responsibility of the authors.
'''

import z3 as z3

from msrex.misc.infix import Infix

from msrex.misc.smt_utils import SMTSolver, SMTConstraint, SAT, UNSAT, UNKNOWN

SMTVAR_COUNT = 0

def get_new_var(prefix="v"):
	global SMTVAR_COUNT
	new_id = SMTVAR_COUNT
	SMTVAR_COUNT += 1
	return "%s%s" % (prefix,new_id)

# Integers

def newInt():
	iname = get_new_var(prefix="i")
	return z3.Int(iname)

def newInts(quantity):
	inames = " ".join( map(lambda _: get_new_var(prefix="i") ,range(0,quantity)) )
	return z3.Ints(inames)

# Booleans

def newBool():
	bname = get_new_var(prefix="b")
	return z3.Bool(bname)

def newBools(quantity):
	bnames = " ".join( map(lambda _: get_new_var(prefix="b") ,range(0,quantity)) )
	return z3.Bools(bnames)

# Locations

Loc = z3.DeclareSort('Loc')

def newLoc():
	lname = get_new_var(prefix="l")
	return z3.Const(lname, Loc)

def newLocs(quantity):
	lnames = " ".join( map(lambda _: get_new_var(prefix="l") ,range(0,quantity)) )
	return z3.Consts(lnames, Loc)

# Destinations

Dest = z3.DeclareSort('Dest')

def newDest():
	dname = get_new_var(prefix="d")
	return z3.Const(dname, Dest)

def newDests(quantity):
	dnames = " ".join( map(lambda _: get_new_var(prefix="d") ,range(0,quantity)) )
	return z3.Consts(dnames, Dest)

# Char

Char = z3.DeclareSort('Char')

def newChar():
	cname = get_new_var(prefix="c")
	return z3.Const(cname, Char)

def newChars(quantity):
	cnames = " ".join( map(lambda _: get_new_var(prefix="c") ,range(0,quantity)) )
	return z3.Consts(cnames, Char)

# String

String = z3.DeclareSort('String')

def newString():
	sname = get_new_var(prefix="str")
	return z3.Const(sname, String)

def newStrings(quantity):
	snames = " ".join( map(lambda _: get_new_var(prefix="str") ,range(0,quantity)) )
	return z3.Consts(snames, String)

# Unknowns

Unknown = z3.DeclareSort('Unknown')

def newUnknown():
	uname = get_new_var(prefix="uk")
	return z3.Const(uname, Unknown)

def newUnknowns(quantity):
	unames = " ".join( map(lambda _: get_new_var(prefix="str") ,range(0,quantity)) )
	return z3.Consts(unames, Unknown)

# Tuples

tuple_sort_dict = {}

def tupleInfo(*sorts):
	name = 'Tup_' + '_'.join(map(lambda sort: sort.name(),sorts))
	if name not in tuple_sort_dict:
		Tuple = z3.Datatype(name)
		sort_sigs = []
		idx = 1
		for sort in sorts:
			sort_sigs.append( ('idx%s' % idx,sort) )
			idx += 1
		Tuple.declare('tup', *sort_sigs)
		Tuple = Tuple.create()
		tuple_sort_dict[name] = { 'sort':Tuple }
	return tuple_sort_dict[name]

def newTuple(*sorts):
	Tuple = tupleInfo(*sorts)['sort']
	tname = get_new_var(prefix="t")
	return z3.Const(tname, Tuple)

def newTuples(quantity, *sorts):
	Tuple = tupleInfo(*sorts)['sort']
	tnames = " ".join( map(lambda _: get_new_var(prefix="t") ,range(0,quantity)) )
	return z3.Consts(tnames, Tuple)

def mk_tup(*args):
	sorts = map(lambda arg: arg.sort() ,args)
	Tuple = tupleInfo(*sorts)['sort']
	return Tuple.tup(*args)

# Lists

list_sort_dict = {}

def listInfo(sort):
	name = sort.name()
	if name not in list_sort_dict:
		List = z3.Datatype("List_%s" % name)
		List.declare('cons', ('head', sort), ('tail', List))
		List.declare('nil')
		List = List.create()
		list_sort_dict[name] = {'sort':List}
	return list_sort_dict[name]

def newList(sort):
	List   = listInfo(sort)['sort']
	lsname = get_new_var(prefix="ls")
	return z3.Const(lsname, List)

def newLists(quantity, *sorts):
	List = listInfo(*sorts)['sort']
	lsnames = " ".join( map(lambda _: get_new_var(prefix="ls") ,range(0,quantity)) )
	return z3.Consts(lsnames, List)

def ls(args, sort):
	List = listInfo(args[0].sort())['sort']
	xs = List.nil
	curr = len(args)-1
	while curr >= 0:
		xs = List.cons(args[curr], xs)
		curr -= 1
	return xs

def mk_ls(*args):
	if len(args) == 0:
		return None
	return ls(args, args[0].sort())

# Sets

set_sort_dict     = {}
set_sort_rev_dict = {}

def setInfo(sort):
	if sort.name() not in set_sort_dict:

		Dummy = z3.Datatype('Dummy_%s' % sort.name())
		Dummy.declare('A')
		Dummy.declare('B')
		Dummy.declare('C')
		# Dummy.declare('D')
		Dummy = Dummy.create()

		Set = z3.Datatype('Set_%s' % sort.name())
		Set.declare('non_empty', ('dummy', Dummy))
		# Set.declare('non_empty_B')
		# Set.declare('non_empty_C')
		Set.declare('empty')
		Set = Set.create()

		mem_f      = z3.Function('mem_f_%s' % sort.name(), sort, Set, z3.BoolSort())
		subseteq_f = z3.Function('subseteq_f_%s' % sort.name(), Set, Set, z3.BoolSort())
		union_f    = z3.Function('union_f_%s' % sort.name(), Set, Set, Set)

		set_info = { 'sort':Set, 'elem':sort, 'mem':mem_f, 'subseteq':subseteq_f, 'union':union_f }
		set_sort_rev_dict[Set.name()] = set_info 
		set_sort_dict[sort.name()]    = set_info

		# forall xs. exists x. x in xs <==> -(xs == empty)		
		x  = z3.Const('x', sort)
		xs = newSet('xs', sort)
		set_empty_axiom = forall([xs], exists([x], (x |mem| xs)) == (xs != Set.empty))

		# axiom of extensionality:
		# forall xs, ys. (forall z. z in xs <==> z in ys) ==> xs == ys
		z  = z3.Const('z', sort)
		xs, ys = newSets('xs ys', sort)
		ext_axiom = forall([xs,ys], forall([z], (z |mem| xs) == (z |mem| ys))  |implies| (xs == ys) )		

		# forall xs,ys. xs << ys ==> forall x. (x in xs) ==> (x in ys)
		x  = z3.Const('x', sort)
		xs, ys = newSets('xs ys', sort)
		subset_axiom1 = forall([xs,ys], (xs |subseteq| ys) |implies| forall([x], (x |mem| xs) |implies| (x |mem| ys)))

		# forall xs,ys. xs << ys ==> (xs = ys) \/ (exists y. y in ys /\ -(y in xs))
		y  = z3.Const('y', sort)
		xs, ys = newSets('xs ys', sort)
		subset_axiom2 = forall([xs,ys], (xs |subseteq| ys) |implies| z3.Or( xs == ys , exists([y], z3.And(y |mem| ys,z3.Not(y |mem| xs)) ) ))

		# forall xs,ys. xs == ys ==> xs << ys /\ ys << xs
		xs, ys = newSets('xs ys', sort)
		subset_axiom3 = forall([xs,ys], (xs == ys) |implies| z3.And(xs |subseteq| ys, ys |subseteq| xs) )

		# forall xs, ys, zs. xs = union(ys,zs) ==> ys << xs /\ zs << xs
		xs, ys, zs = newSets('xs ys zs', sort)
		union_axiom1 = forall([xs,ys,zs], (xs == (ys |union| zs)) |implies| z3.And(ys |subseteq| xs,zs |subseteq| xs) )

		# forall xs, ys. union(xs,ys) == union(ys,xs)
		xs, ys = newSets('xs ys', sort)
		union_axiom2 = forall([xs,ys], (xs |union| ys) == (ys |union| xs))

		# forall xs, ys, zs, x. xs = union(ys,zs) /\ x in xs ==> x in ys \/ x in zs
		xs, ys, zs = newSets('xs ys zs', sort)
		x  = z3.Const('x', sort)
		union_axiom3 = forall([xs,ys,zs,x], z3.And(xs == (ys |union| zs), x |mem| xs) |implies| z3.Or(x |mem| ys,x |mem| zs) )

		set_info['axioms'] = [set_empty_axiom, ext_axiom
                                     ,subset_axiom1, subset_axiom2, subset_axiom3
                                     ,union_axiom1, union_axiom2, union_axiom3]
	return set_sort_dict[sort.name()]

def setInfoFromSet(sort):
	return set_sort_rev_dict[sort.name()]

def setAxioms(sort):
	return set_sort_dict[sort.name()]['axioms']

def setAxiomsFromSet(sort):
	return set_sort_rev_dict[sort.name()]['axioms']

@Infix
def mem(x ,xs):
	mem_f = setInfoFromSet(xs.sort())['mem']
	return mem_f(x,xs)==True

@Infix
def subseteq(xs ,ys):
	subseteq_f = setInfoFromSet(xs.sort())['subseteq']
	return subseteq_f(xs,ys)==True

@Infix
def union(xs ,ys):
	union_f = setInfoFromSet(xs.sort())['union']
	return union_f(xs,ys)

@Infix
def implies(ps, cs):
	return z3.Implies(ps, cs)

@Infix
def iff(cs1, cs2):
	return cs1 == cs2

def forall(xs, cs):
	return z3.ForAll(xs, cs)

def exists(xs, cs):
	return z3.Exists(xs, cs)

@Infix
def _And_(c1, c2):
	return z3.And(c1, c2)

def newSet(sort):
	Set = setInfo(sort)['sort']
	sname = get_new_var(prefix="s")
	return z3.Const(sname, Set)

def newSets(quantity, sort):
	Set = setInfo(sort)['sort']
	snames = " ".join( map(lambda _: get_new_var(prefix="s") ,range(0,quantity)) )
	return z3.Consts(snames, Set)

def empty(sort):
	return setInfoFromSet(sort)['sort'].empty

